--- AtomicParsley.cpp.orig	2010-07-23 00:42:26.000000000 +0200
+++ AtomicParsley.cpp	2010-07-23 00:54:36.000000000 +0200
@@ -1447,7 +1447,7 @@
 	uint32_t atom_offsets = 0;
 	char* uuid_outfile = (char*)calloc(1, sizeof(char)*MAXPATHLEN+1); //malloc a new string because it may be a cli arg for a specific output path	
 	if (output_path == NULL) {
-		char* orig_suffix = strrchr(originating_file, '.');
+		const char* orig_suffix = strrchr(originating_file, '.');
 		if (orig_suffix == NULL) {
 			fprintf(stdout, "AP warning: a file extension for the input file was not found.\n\tGlobbing onto original filename...\n");
 			path_len = strlen(originating_file);
@@ -4030,21 +4030,21 @@
 		//+8 so that 'free' can be accommodated; can't write a 'free' atom of length = 5 - min is 8; OR it disappears entirely
 		if ( (int)udta_dynamics.max_usable_free_space >= userdata_difference + 8 || 
 		       userdata_difference <= -8 ||
-					 ( (int)udta_dynamics.max_usable_free_space >= 8 && -8 < userdata_difference < 0 ) || 
+					 ( (int)udta_dynamics.max_usable_free_space >= 8 && -8 < userdata_difference && userdata_difference< 0 ) || 
 					 (int)udta_dynamics.max_usable_free_space == userdata_difference) { 
 			//fprintf(stdout, "Dynamically update possible: change = %i, free = %i\n", userdata_difference , udta_dynamics.max_usable_free_space);
 			if (!moov_atom_was_mooved) { //only allow dynamic updating when moov precedes any mdat atoms...
 				udta_dynamics.dynamic_updating = true;
 			} else {
 				//if there is insufficient padding when moov is rearranged to precede mdat, add default padding
-				if (pad_prefs.minimum_required_padding_size < udta_dynamics.max_usable_free_space < pad_prefs.default_padding_size) {
+				if (pad_prefs.minimum_required_padding_size < udta_dynamics.max_usable_free_space && udta_dynamics.max_usable_free_space < pad_prefs.default_padding_size) {
 					APar_ForcePadding(pad_prefs.default_padding_size);
 				}
 				APar_DetermineAtomLengths();
 				return;
 			}
 			//fprintf(stdout, "I'm here %u , %u, %i - %i\n", udta_dynamics.max_usable_free_space, pad_prefs.default_padding_size, udta_dynamics.free_atom_repository, udta_dynamics.free_atom_secondary_repository);
-			if (pad_prefs.minimum_required_padding_size < udta_dynamics.max_usable_free_space < pad_prefs.default_padding_size) {
+			if (pad_prefs.minimum_required_padding_size < udta_dynamics.max_usable_free_space && udta_dynamics.max_usable_free_space < pad_prefs.default_padding_size) {
 				APar_ForcePadding(pad_prefs.default_padding_size);
 			}
 			if (pad_prefs.minimum_required_padding_size > udta_dynamics.max_usable_free_space) {
@@ -4462,7 +4462,7 @@
 #endif
 
 void APar_DeriveNewPath(const char *filePath, char* temp_path, int output_type, const char* file_kind, char* forced_suffix, bool random_filename = true) {
-	char* suffix = NULL;
+	const char* suffix = NULL;
 	if (forced_suffix == NULL) {
 		suffix = strrchr(filePath, '.');
 	} else {
@@ -4480,7 +4480,7 @@
 		memcpy(temp_path, filePath, base_len);
 		memcpy(temp_path + base_len, file_kind, strlen(file_kind));
 #else
-		char* file_name = strrchr(filePath, '/');
+		const char* file_name = strrchr(filePath, '/');
 		size_t file_name_len = strlen(file_name);
 		memcpy(temp_path, filePath, filepath_len-file_name_len+1);
 		memcpy(temp_path + strlen(temp_path), ".", 1);
@@ -5006,7 +5006,7 @@
 			free_modified_name = true;
 			if (forced_suffix_type == FORCE_M4B_TYPE) { //using --stik Audiobook with --overWrite will change the original file's extension
 				uint16_t filename_len = strlen(m4aFile);
-				char* suffix = strrchr(m4aFile, '.');
+				const char* suffix = strrchr(m4aFile, '.');
 				memcpy(originating_file, m4aFile, filename_len+1 );
 				memcpy(originating_file + (filename_len - strlen(suffix) ), ".m4b", 5 );
 			}
